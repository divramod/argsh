#!/usr/bin/env bash
set -eu -o pipefail

export ARGSH_ACTIONS
export ARGSH_SOURCE
: "${ARGSH_SOURCE:="${BASH_SOURCE[-1]}"}"


_argsh_parse() {
  awk 'BEGIN { OFS="\t" } {
    match($0, /# argsh\(([^)|]+)?\|?([^)]+)?\)/, args)
    if (args[0]) {
      $0 = substr($0, RSTART + RLENGTH)
      while(match($0, /[:)] +(opt|def|val|des)\(([^)]*)/, opt)) {
        args[opt[1]] = opt[2] ? opt[2] : "-"
        $0 = substr($0, RSTART + RLENGTH)
      }
      if (length(args[1]) > 1) {
        args[2] = args[1]
        args[1] = ""
      }
      print args[1], args[2], args["opt"], args["def"], args["val"], args["des"]
    }
  } END {
    print "h\thelp\t\t\t\tPrint help."
  }'
}

_argsh_declare() {
  eval "$(awk 'BEGIN { FS="\t" } $3 {
    printf "export %s%s\n", $3, $4 ? "='\''" $4 "'\''" : ""
  }')"
}

# shellcheck disable=SC2034
_argsh_arguments() {
  local -r args="$(awk 'BEGIN { FS="\t"; OFS="\t" } {
    print $1, $2, $3, $5
  }')"
  local file_error
  file_error="$(mktemp)"
  trap "rm ${file_error}" EXIT

  get() {
    local -r param="${1}" col="${2}"
    echo "${args}" |
      awk -v FS='\t' "\$1 == \"${param}\" || \$2 == \"${param}\" { print \$${col} }"
  }
  opts() {
    local -r col="${1}"
    echo "${args}" |
      awk -v FS='\t' "\$${col} { print \$${col} (\$4 ? \":\" : \"\") }" |
      paste -sd ,
  }
  error() {
    local -r msg="$(sed 's/^getopt: //' "${file_error}")"
    [ -z "${msg}" ] || {
      _usage "${msg}"
      exit 2
    }
  }
  noop() {
    declare -n ref="${1}"
    ref="$(cat)"
  }

  local params
  params="$(getopt -o "$(opts 1)" -l "$(opts 2)" -- "$@" 2>"${file_error}" || true)"
  error >&2

  eval set -- "${params}"
  local opt val
  until [ "${1}" = '--' ]; do
    cmd="$(sed 's/^-*//' <<<"${1}")"
    shift

    if [ "${cmd}" == "h" ] || [ "${cmd}" == "help" ]; then
      _usage
      exit
    fi

    opt="$(get "${cmd}" 3)"
    if [ -n "${opt}" ]; then
      declare -n ref="${opt}"
      val="$(get "${cmd}" 4)"
      [ -n "${val}" ] || {
        ref=true
        continue
      }

      declare -f "${val}" &>/dev/null || {
        [ "${val}" == "-" ] ||
          echo -e "[args][warning]\tfunction does not exists '${val}'" 1>&2
        val="noop"
      }
      # call val function
      "${val}" "${opt}" "${cmd}" <<<"${1}" 2>"${file_error}"
      error >&2
      shift
      continue
    fi

    ARGSH_ACTIONS+="${cmd}"$'\n'
  done

  ARGSH_ACTIONS="${ARGSH_ACTIONS-%$'\n'}"
}

_argsh_usage() {
  local -r args="$(awk 'BEGIN { FS="\t"; OFS="\t" } {
    printf "%s\t  %-23s  %s\n", $3,
      ($1 ? "-"$1 : "") ($1 && $2 ? ", " : "") ($2 ? "--"$2 : ""), $6
    if ($4) {
      printf "%s\t %-25s ➜ %s\n", "-", "", $4
    }
  }')"

  source /dev/stdin <<-EOF
_usage() {
  local -r message="\${1:-""}"

  [ -n "\${message}" ] &&
    echo -e "\n\033[31m■■\033[0m \033[1m\${message}\033[0m"
  cat <<-EOTXT

Usage:
  \$(basename "${ARGSH_SOURCE}") [options]

Options:
$(echo "${args}" | awk -v FS='\t' '$1 { print $2; }')

Actions:
$(echo "${args}" | awk -v FS='\t' '! $1 { print $2; }')
EOTXT
}
EOF
}

_argsh() {
  # TODO: do not fail of there is no argsh comment
  local -r args="$(
    grep -E '^# argsh\(.+\):' "${ARGSH_SOURCE}" |
      _argsh_parse
  )"

  _argsh_usage \
    <<<"${args}"
  [ -n "${*}" ] || {
    _usage
    exit 1
  }
  _argsh_declare \
    <<<"${args}"
  _argsh_arguments "${@}" \
    <<<"${args}"
}
